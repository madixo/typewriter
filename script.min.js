class TypewriterAnimation{constructor(t,e={},s={}){this.parent=t,this.handlers=new Proxy(e,{get:(t,e)=>{if(t.hasOwnProperty(e))return t[e];console.log(`${t}.${e} not specified!`)}}),this.options=new Proxy(s,{get:(t,e)=>{switch(e){case"delay":return t.hasOwnProperty("delay")?t.delay:100;case"fluctuation":return t.hasOwnProperty("fluctuation")?t.fluctuation:50;default:return t[e]}}})}get random(){return Math.random()*(2*this.options.fluctuation)-this.options.fluctuation}animate(){return new Promise(t=>{this.res=t,this.handlers.init(),this.salt=this.random,this._animate()})}_animate(t=performance.now()){const{delay:e}=this.options;(void 0===this.last?e+Math.ceil(this.salt):t-this.last)>=e+this.salt&&(this.handlers.anim(),this.salt=this.random,this.last=t),this.handlers.cond()?requestAnimationFrame(this._animate.bind(this)):this.res("done")}}class TypewriterWrite extends TypewriterAnimation{constructor(t,e,s){super(t,{init:()=>{this.buffer=[...this.text]},anim:()=>{this.parent.innerHTML+=this.buffer.shift()},cond:()=>this.buffer.length},s),this.text=e}}class TypewriterDelete extends TypewriterAnimation{constructor(t,e,s){super(t,{init:()=>{this.text=[...this.parent.innerHTML],this.counter=this.to_delete},anim:()=>{this.text.pop(),this.parent.innerHTML=this.text.join(""),this.counter--},cond:()=>this.counter},s),this.to_delete=e}}class TypewriterSleep{constructor(t){this.ms=t}sleep(){return new Promise(t=>setTimeout(t,this.ms))}}class Typewriter{constructor(t,e={}){this.parent=t,this.steps=[],this.step=0,this.paused=!1,this.options=new Proxy(e,{get:(t,e)=>{switch(e){case"repeat":return!!t.hasOwnProperty("repeat")&&t.repeat;default:return t[e]}}})}write(t,e){return this.steps.push(new TypewriterWrite(this.parent,t,e||this.options)),this}rewrite(t,e,s){return this.steps.push(new TypewriterDelete(this.parent,t,s||this.options)),this.steps.push(new TypewriterWrite(this.parent,e,s||this.options)),this}delete(t,e){return this.steps.push(new TypewriterDelete(this.parent,t,e||this.options)),this}sleep(t){return this.steps.push(new TypewriterSleep(t)),this}start(){this.step=0,this.resume()}async animate(){for(;this.step<this.steps.length&&!this.paused;this.step++){const t=this.steps[this.step];if(t instanceof TypewriterAnimation)await t.animate();else{if(!(t instanceof TypewriterSleep))throw new Error(`Invalid item in queue ${t}!`);await t.sleep()}}this.options.repeat?requestAnimationFrame(this.start.bind(this)):this.stop()}stop(){this.pause()}pause(){this.paused=!0}resume(){this.paused=!1,this.steps,this.animate()}}